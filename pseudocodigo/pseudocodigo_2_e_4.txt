INÍCIO

// Definir constantes
N ← 10 // Tamanho do grid (10x10)
direcoes ← [(0, 1), (1, 0), (0, -1), (-1, 0)] // Direções: direita, baixo, esquerda, cima
obstaculos ← {(0, 5), (1, 7), (1, 4), (2, 3), (3, 3), (4, 3), (4, 6), (5, 8), (6, 4), (7, 3), (7, 5), (7, 6), (8, 6), (9, 5)} // Posições dos obstáculos

// Função para plotar o grid
FUNÇÃO plotar_grid(posicao, visitadas)
    CRIAR grid ← matriz de zeros (N x N)
    
    // Marcar obstáculos no grid
    PARA CADA (x, y) EM obstaculos
        grid[x, y] ← -1
    FIM-PARA
    
    // Marcar células visitadas no grid
    PARA CADA (x, y) EM visitadas
        grid[x, y] ← 1
    FIM-PARA
    
    // Marcar posição atual do robô
    grid[posicao] ← 2
    
    // Exibir grid com mapa de cores
    EXIBIR_IMAGEM(grid, mapa_de_cores="Blues")
    HABILITAR_GRADE()
    REMOVER_MARCADORES_EIXOS()
    PAUSAR_EXIBIÇÃO(0.1 segundos)
    LIMPAR_TELA()
FIM-FUNÇÃO

// Função para busca em largura (BFS)
FUNÇÃO bfs(celula_inicial, visitadas)
    CRIAR fila ← deque([celula_inicial])
    CRIAR predecessores ← {celula_inicial: Nulo}
    
    ENQUANTO fila NÃO ESTIVER VAZIA
        (x, y) ← fila.REMOVER_PRIMEIRO()
        
        // Verificar se célula atual não foi visitada
        SE (x, y) NÃO ESTIVER EM visitadas
            CRIAR caminho ← lista vazia
            atual ← (x, y)
            
            // Reconstruir caminho a partir dos predecessores
            ENQUANTO atual NÃO FOR Nulo
                ADICIONAR atual AO caminho
                atual ← predecessores[atual]
            FIM-ENQUANTO
            
            INVERTER caminho
            RETORNAR caminho
        FIM-SE
        
        // Explorar vizinhos
        PARA CADA (dx, dy) EM direcoes
            nx ← x + dx
            ny ← y + dy
            
            // Verificar se vizinho é válido
            SE (0 ≤ nx < N E 0 ≤ ny < N E
                (nx, ny) NÃO ESTIVER EM obstaculos E
                (nx, ny) NÃO ESTIVER EM predecessores)
                predecessores[(nx, ny)] ← (x, y)
                fila.ADICIONAR((nx, ny))
            FIM-SE
        FIM-PARA
    FIM-ENQUANTO
    
    RETORNAR Nulo // Nenhuma célula não visitada encontrada
FIM-FUNÇÃO

// Função principal para mover o robô
FUNÇÃO mover_robo()
    // Escolher posição inicial aleatória do robô
    ENQUANTO Verdadeiro
        robo ← (ALEATÓRIO(0, N-1), ALEATÓRIO(0, N-1))
        SE robo NÃO ESTIVER EM obstaculos
            SAIR DO LOOP
        FIM-SE
    FIM-ENQUANTO
    
    CRIAR visitadas ← conjunto contendo apenas robo
    passos_totais ← 0
    
    CRIAR_JANELA_GRAFICA(tamanho=(6, 6))
    
    // Loop principal de exploração
    ENQUANTO Verdadeiro
        plotar_grid(robo, visitadas)
        
        caminho ← bfs(robo, visitadas)
        
        // Parar se não houver mais células não visitadas
        SE caminho FOR Nulo
            SAIR DO LOOP
        FIM-SE
        
        // Seguir o caminho encontrado
        PARA CADA proxima EM caminho[1:]
            robo ← proxima
            ADICIONAR robo A visitadas
            INCREMENTAR passos_totais
            plotar_grid(robo, visitadas)
        FIM-PARA
    FIM-ENQUANTO
    
    // Calcular métricas
    celulas_acessiveis ← N * N - TAMANHO(obstaculos)
    completude ← (TAMANHO(visitadas) / celulas_acessiveis) * 100
    
    FECHAR_JANELA_GRAFICA()
    
    // Exibir resultados
    EXIBIR "Exploração concluída!"
    EXIBIR "Total de células acessíveis: ", celulas_acessiveis
    EXIBIR "Células visitadas: ", TAMANHO(visitadas)
    EXIBIR "Completude: ", completude (formatado com 2 casas decimais), "%"
    EXIBIR "Passos totais: ", passos_totais
    EXIBIR "Passos redundantes: ", passos_totais - TAMANHO(visitadas)
    EXIBIR "Sucesso no desvio: ", "Sim" SE completude = 100 SENÃO "Não"
FIM-FUNÇÃO

// Executar programa
SE programa for executado diretamente
    mover_robo()
FIM-SE

FIM

----------------------------------------------------------------------------------

Quatro-four_parcial

INÍCIO

// Definir constantes
ROWS ← 11 // Número de linhas do grid
COLS ← 10 // Número de colunas do grid
DIRECTIONS ← [(0, 1), (1, 0), (0, -1), (-1, 0)] // Direções: direita, baixo, esquerda, cima
REAL_GRID_COSTS ← matriz 11x10 com custos de terreno predefinidos

// Função heurística (distância de Manhattan)
FUNÇÃO heuristic(a, b)
    RETORNAR |a[0] - b[0]| + |a[1] - b[1]|
FIM-FUNÇÃO

// Função para gerar nós inicial e final distantes
FUNÇÃO generate_distant_nodes()
    min_distance ← (ROWS + COLS) / 2
    ENQUANTO Verdadeiro
        start_node ← (ALEATÓRIO(0, ROWS-1), ALEATÓRIO(0, COLS-1))
        goal_node ← (ALEATÓRIO(0, ROWS-1), ALEATÓRIO(0, COLS-1))
        SE start_node ≠ goal_node E heuristic(start_node, goal_node) ≥ min_distance
            RETORNAR start_node, goal_node
        FIM-SE
    FIM-ENQUANTO
FIM-FUNÇÃO

// Função para encontrar caminho usando A*
FUNÇÃO find_path_a_star(known_costs, start, goal)
    CRIAR open_set ← fila de prioridade vazia
    ADICIONAR (0, start) A open_set
    CRIAR came_from ← dicionário vazio
    CRIAR g_score ← dicionário com infinito para todas as células (r, c)
    g_score[start] ← 0
    CRIAR f_score ← dicionário com infinito para todas as células (r, c)
    f_score[start] ← heuristic(start, goal)
    
    ENQUANTO open_set NÃO ESTIVER VAZIA
        (_, current) ← REMOVER menor elemento de open_set
        
        SE current = goal
            CRIAR path ← lista vazia
            ENQUANTO current ESTIVER EM came_from
                ADICIONAR current A path
                current ← came_from[current]
            FIM-ENQUANTO
            ADICIONAR start A path
            RETORNAR path INVERTIDO
        FIM-SE
        
        PARA CADA (dr, dc) EM DIRECTIONS
            neighbor ← (current[0] + dr, current[1] + dc)
            SE neighbor NÃO ESTIVER DENTRO DOS LIMITES (0 ≤ r < ROWS, 0 ≤ c < COLS)
                CONTINUAR
            FIM-SE
            
            move_cost ← known_costs[neighbor[0], neighbor[1]]
            tentative_g_score ← g_score[current] + move_cost
            
            SE tentative_g_score < g_score[neighbor]
                came_from[neighbor] ← current
                g_score[neighbor] ← tentative_g_score
                f_score[neighbor] ← tentative_g_score + heuristic(neighbor, goal)
                ADICIONAR (f_score[neighbor], neighbor) A open_set
            FIM-SE
        FIM-PARA
    FIM-ENQUANTO
    
    RETORNAR Nulo // Nenhum caminho encontrado
FIM-FUNÇÃO

// Função para animar a visualização do ambiente parcialmente observável
FUNÇÃO animate_partial_view(agent_pos, known_costs, path_taken, start_node, goal_node)
    CRIAR terrain_colors ← {0: '#cccccc', 1: '#2d6a4f', 2: '#fca311', 3: '#b21807'}
    DEFINIR path_color ← '#a2d2ff', robot_color ← '#0077b6', start_color ← '#52b788', goal_color ← '#e5383b'
    CRIAR color_grid ← matriz de zeros (ROWS x COLS x 3)
    
    // Colorir o grid com base nos custos conhecidos
    PARA r DE 0 ATÉ ROWS-1
        PARA c DE 0 ATÉ COLS-1
            hex_color ← terrain_colors[known_costs[r, c]] OU '#FFFFFF'
            color_grid[r, c] ← CONVERTER hex_color PARA RGB
        FIM-PARA
    FIM-PARA
    
    // Colorir o caminho percorrido
    PARA CADA (r, c) EM path_taken
        color_grid[r, c] ← CONVERTER path_color PARA RGB
    FIM-PARA
    
    // Colorir nós inicial, final e posição do agente
    color_grid[start_node] ← CONVERTER start_color PARA RGB
    color_grid[goal_node] ← CONVERTER goal_color PARA RGB
    color_grid[agent_pos] ← CONVERTER robot_color PARA RGB
    
    // Exibir grid
    EXIBIR_IMAGEM(color_grid / 255.0)
    DEFINIR_TITULO("Partially Observable Environment")
    HABILITAR_GRADE(cor='k', largura=0.5)
    REMOVER_MARCADORES_EIXOS()
    PAUSAR_EXIBIÇÃO(0.25 segundos)
FIM-FUNÇÃO

// Programa principal
SE programa for executado diretamente
    start_node, goal_node ← generate_distant_nodes()
    
    CRIAR known_grid_costs ← matriz de zeros (ROWS x COLS)
    agent_pos ← start_node
    CRIAR path_taken ← [agent_pos]
    total_cost_incurred ← 0
    
    CRIAR_JANELA_GRAFICA(tamanho=(7, 8))
    EXIBIR "Stage 4: Partially Observable Environment"
    EXIBIR "Objective: Find a path from ", start_node, " to ", goal_node, " with limited knowledge."
    
    ENQUANTO agent_pos ≠ goal_node
        // Atualizar custos conhecidos ao redor do agente
        PARA CADA (dr, dc) EM DIRECTIONS + [(0, 0)]
            r ← agent_pos[0] + dr
            c ← agent_pos[1] + dc
            SE 0 ≤ r < ROWS E 0 ≤ c < COLS
                known_grid_costs[r, c] ← REAL_GRID_COSTS[r, c]
            FIM-SE
        FIM-PARA
        
        // Planejar caminho com custos conhecidos
        plan_costs ← SUBSTITUIR zeros EM known_grid_costs POR 1
        planned_path ← find_path_a_star(plan_costs, agent_pos, goal_node)
        
        SE planned_path FOR Nulo OU TAMANHO(planned_path) < 2
            EXIBIR "Agent is trapped or cannot find a path based on current knowledge."
            SAIR DO LOOP
        FIM-SE
        
        // Mover agente para o próximo passo
        next_step ← planned_path[1]
        agent_pos ← next_step
        ADICIONAR agent_pos A path_taken
        INCREMENTAR total_cost_incurred POR REAL_GRID_COSTS[agent_pos]
        
        animate_partial_view(agent_pos, known_grid_costs, path_taken, start_node, goal_node)
    FIM-ENQUANTO
    
    DEFINIR_TITULO("Exploration Complete! Close window to finish.")
    EXIBIR_JANELA_GRAFICA()
    
    // Exibir resultados
    SE agent_pos = goal_node
        EXIBIR "Goal reached!"
        EXIBIR "Task Success: Yes"
        EXIBIR "Total Path Cost: ", total_cost_incurred
    SENÃO
        EXIBIR "Goal not reached."
    FIM-SE
FIM-SE

FIM

---------------------------------------------------------------------------------

INÍCIO

// Definir constantes
ROWS ← 11 // Número de linhas do grid
COLS ← 10 // Número de colunas do grid
DIRECTIONS ← [(0, 1), (1, 0), (0, -1), (-1, 0)] // Direções: direita, baixo, esquerda, cima
GRID_COSTS ← matriz 11x10 com custos de terreno predefinidos

// Função heurística (distância de Manhattan)
FUNÇÃO heuristic(a, b)
    RETORNAR |a[0] - b[0]| + |a[1] - b[1]|
FIM-FUNÇÃO

// Função para gerar nós inicial e final distantes
FUNÇÃO generate_distant_nodes()
    min_distance ← (ROWS + COLS) / 2
    ENQUANTO Verdadeiro
        start_node ← (ALEATÓRIO(0, ROWS-1), ALEATÓRIO(0, COLS-1))
        goal_node ← (ALEATÓRIO(0, ROWS-1), ALEATÓRIO(0, COLS-1))
        SE start_node ≠ goal_node E heuristic(start_node, goal_node) ≥ min_distance
            RETORNAR start_node, goal_node
        FIM-SE
    FIM-ENQUANTO
FIM-FUNÇÃO

// Função para encontrar caminho usando A*
FUNÇÃO find_path_a_star(grid_costs, start, goal)
    CRIAR open_set ← fila de prioridade vazia
    ADICIONAR (0, start) A open_set
    CRIAR came_from ← dicionário vazio
    CRIAR g_score ← dicionário com infinito para todas as células (r, c)
    g_score[start] ← 0
    CRIAR f_score ← dicionário com infinito para todas as células (r, c)
    f_score[start] ← heuristic(start, goal)
    
    ENQUANTO open_set NÃO ESTIVER VAZIA
        (_, current) ← REMOVER menor elemento de open_set
        
        SE current = goal
            CRIAR path ← lista vazia
            ENQUANTO current ESTIVER EM came_from
                ADICIONAR current A path
                current ← came_from[current]
            FIM-ENQUANTO
            ADICIONAR start A path
            RETORNAR path INVERTIDO
        FIM-SE
        
        PARA CADA (dr, dc) EM DIRECTIONS
            neighbor ← (current[0] + dr, current[1] + dc)
            SE neighbor NÃO ESTIVER DENTRO DOS LIMITES (0 ≤ r < ROWS, 0 ≤ c < COLS)
                CONTINUAR
            FIM-SE
            
            move_cost ← grid_costs[neighbor[0], neighbor[1]]
            tentative_g_score ← g_score[current] + move_cost
            
            SE tentative_g_score < g_score[neighbor]
                came_from[neighbor] ← current
                g_score[neighbor] ← tentative_g_score
                f_score[neighbor] ← tentative_g_score + heuristic(neighbor, goal)
                ADICIONAR (f_score[neighbor], neighbor) A open_set
            FIM-SE
        FIM-PARA
    FIM-ENQUANTO
    
    RETORNAR Nulo // Nenhum caminho encontrado
FIM-FUNÇÃO

// Função para animar o caminho percorrido
FUNÇÃO animate_path(path, grid_costs, start_node, goal_node)
    CRIAR terrain_colors ← {1: '#2d6a4f', 2: '#fca311', 3: '#b21807'}
    DEFINIR path_color ← '#a2d2ff', robot_color ← '#0077b6', start_color ← '#52b788', goal_color ← '#e5383b'
    CRIAR_JANELA_GRAFICA(tamanho=(7, 8))
    
    PARA CADA position EM path
        CRIAR color_grid ← matriz de zeros (ROWS x COLS x 3)
        
        // Colorir o grid com base nos custos do terreno
        PARA r DE 0 ATÉ ROWS-1
            PARA c DE 0 ATÉ COLS-1
                hex_color ← terrain_colors[grid_costs[r, c]] OU '#FFFFFF'
                color_grid[r, c] ← CONVERTER hex_color PARA RGB
            FIM-PARA
        FIM-PARA
        
        // Colorir o caminho percorrido até a posição atual
        PARA CADA (r, c) EM path
            SE (r, c) = position
                SAIR DO LOOP
            FIM-SE
            color_grid[r, c] ← CONVERTER path_color PARA RGB
        FIM-PARA
        
        // Colorir nós inicial, final e posição do agente
        color_grid[start_node] ← CONVERTER start_color PARA RGB
        color_grid[goal_node] ← CONVERTER goal_color PARA RGB
        color_grid[position] ← CONVERTER robot_color PARA RGB
        
        // Exibir grid
        EXIBIR_IMAGEM(color_grid / 255.0)
        DEFINIR_TITULO("Utility-Based Agent in Action (A* Search)")
        HABILITAR_GRADE(cor='k', largura=0.5)
        REMOVER_MARCADORES_EIXOS()
        PAUSAR_EXIBIÇÃO(0.25 segundos)
    FIM-PARA
    
    DEFINIR_TITULO("Path Complete! Close the window to finish.")
    EXIBIR_JANELA_GRAFICA()
FIM-FUNÇÃO

// Programa principal
SE programa for executado diretamente
    start_node, goal_node ← generate_distant_nodes()
    
    EXIBIR "Stage 4: Fully Observable Environment"
    EXIBIR "Objective: Find the minimum cost path from ", start_node, " to ", goal_node
    
    found_path ← find_path_a_star(GRID_COSTS, start_node, goal_node)
    
    SE found_path NÃO FOR Nulo
        total_cost ← SOMAR GRID_COSTS[r, c] PARA CADA (r, c) EM found_path[1:]
        EXIBIR "Path found!"
        EXIBIR "Task Success: Yes"
        EXIBIR "Total Path Cost: ", total_cost
        EXIBIR "Starting animation..."
        animate_path(found_path, GRID_COSTS, start_node, goal_node)
        EXIBIR "Animation finished."
    SENÃO
        EXIBIR "Could not find a path."
    FIM-SE
FIM-SE

FIM